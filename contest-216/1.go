package main

import (
	"fmt"
	"sort"
	"strings"
)

func main() {
	// 输入：n = 3, k = 27
	// 输出："aay"
	// 解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。
	// 示例 2：

	// 输入：n = 5, k = 73
	// 输出："aaszz"
	// getSmallestString(3, 27)
	// getSmallestString(5, 73)
	// getSmallestString(4, 100) // vzzz
	// getSmallestString(5, 31)  // "aaabz"
	// getSmallestString(96014, 2095650) // "aaabz"

	// minimumEffort([][]int{{1, 2}, {2, 4}, {4, 8}})
	// 	输入：tasks = [[1,2],[2,4],[4,8]]
	// 输出：8
	// 解释：
	// 一开始有 8 能量，我们按照如下顺序完成任务：
	//     - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。
	//     - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。
	//     - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。
	// 注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。
	// 示例 2：
	// minimumEffort([][]int{{1, 3}, {2, 4}, {10, 11}, {10, 12}, {8, 9}})
	// 输入：tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
	// 输出：32
	// 解释：
	// 一开始有 32 能量，我们按照如下顺序完成任务：
	//     - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。
	//     - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。
	//     - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。
	//     - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。
	//     - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。
	// 示例 3：
	// minimumEffort([][]int{{1, 7}, {2, 8}, {3, 9}, {4, 10}, {5, 11}, {6, 12}})
	// minimumEffort([][]int{{4738, 7608}, {3838, 9478}, {173, 2857}, {6139, 9833}, {5509, 8352}, {2942, 3253}, {870, 6727}, {4210, 8378}, {4581, 5234}, {2240, 2261}, {6750, 9895}, {3947, 8168}, {2907, 7234}, {1546, 5789}, {3388, 9499}, {5735, 7075}, {1709, 7890}, {4565, 7808}, {3779, 4260}, {4321, 4610}, {2981, 9709}, {418, 7120}, {2571, 8119}, {1063, 7268}, {6462, 7480}, {9492, 9642}, {2446, 4869}, {2276, 3177}, {2115, 7614}, {4383, 7475}, {4240, 5242}, {1280, 7417}, {4336, 5767}, {1028, 6241}, {922, 4459}, {721, 3063}, {5120, 5267}, {1818, 7408}, {1224, 7859}, {4172, 4971}, {3787, 6326}, {3614, 4813}, {6350, 9148}, {3761, 3795}, {3889, 5846}, {3886, 4693}, {3149, 4945}, {1189, 7198}, {1677, 8510}, {6125, 7112}, {2469, 6213}, {7590, 9131}, {5, 1305}, {7563, 9006}, {4096, 4749}, {1528, 8672}, {1183, 6845}, {2626, 7098}, {4786, 6481}, {277, 8043}, {2537, 5264}, {151, 9109}, {1765, 8516}, {489, 8947}, {4022, 8205}, {2236, 5188}, {644, 1030}, {989, 2894}, {6216, 7476}, {4390, 9640}, {3594, 9320}, {328, 7237}, {948, 5889}, {2250, 2931}, {1653, 7167}, {7045, 9563}, {1529, 4810}, {4391, 6679}, {3886, 5121}, {1135, 6214}, {374, 3917}, {1302, 1723}, {1156, 3893}, {1415, 1999}, {3247, 3491}, {4890, 7112}, {2449, 5732}, {6625, 6946}, {3268, 6336}, {5418, 9394}, {4501, 5139}, {7592, 8864}, {1719, 9225}, {2137, 6469}, {2592, 9567}, {3180, 7759}, {5982, 6038}, {389, 9925}, {5962, 7983}, {20, 6489}, {2082, 6450}, {2109, 5612}, {2906, 3362}, {326, 5780}})
	// 输入：tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
	// 输出：27
	// 解释：
	// 一开始有 27 能量，我们按照如下顺序完成任务：
	//     - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。
	//     - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。
	//     - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。
	//     - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。
	//     - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。
	//     - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。

	waysToMakeFair([]int{2, 1, 6, 4})
	// 输入：nums = [2,1,6,4]
	// 输出：1
	// 解释：
	// 删除下标 0 ：[1,6,4] -> 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。
	// 删除下标 1 ：[2,6,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。
	// 删除下标 2 ：[2,1,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。
	// 删除下标 3 ：[2,1,6] -> 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。
	// 只有一种让剩余数组成为平衡数组的方案。
	// 示例 2：

	waysToMakeFair([]int{1, 1, 1})
	// 输入：nums = [1,1,1]
	// 输出：3
	// 解释：你可以删除任意元素，剩余数组都是平衡数组。
	// 示例 3：
	waysToMakeFair([]int{1, 2, 3})
	// 输入：nums = [1,2,3]
	// 输出：0
	// 解释：不管删除哪个元素，剩下数组都不是平衡数组。

}
func waysToMakeFair(nums []int) int {
	n := len(nums)
	odd := make([]int, n+1)
	even := make([]int, n+1)
	for i := 0; i < n; i++ {
		if i%2 == 0 {
			even[i+1] = even[i] + nums[i]
			odd[i+1] = odd[i]
		} else {
			odd[i+1] = odd[i] + nums[i]
			even[i+1] = even[i]
		}
	}
	ans := 0
	for i := 0; i < n; i++ {
		leftOdd, leftEven := odd[i]-odd[0], even[i]-even[0]
		rightOdd, rightEven := odd[n]-odd[i+1], even[n]-even[i+1]
		// fmt.Println("not i ", i)
		// fmt.Println(" left odd even", leftOdd, leftEven)
		// fmt.Println(" right odd even", rightOdd, rightEven)
		if leftOdd+rightEven == leftEven+rightOdd {
			ans++
		}
	}
	fmt.Println("ans", ans)
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
func getSmallestString(n int, k int) string {
	// 贪心的方式
	strs := ""
	for toMod := min(26, k); toMod >= 1; toMod-- {
		part, leave := k/toMod, k%toMod
		c := string('a' + toMod - 1)
		for p := part; p >= 1; p-- {
			if p+leave+(part-p)*toMod >= n {
				// fmt.Println(p, leave, n, c)
				char := strings.Repeat(c, p)
				k -= toMod * p
				n -= p
				strs = char + strs
				break
			}
		}
		// for k > 0 && n >= 1 && k-toMod >= n-1 {
		// 	// fmt.Print(c)
		// 	strs = c + strs
		// 	k -= toMod
		// 	n--
		// }
	}
	// fmt.Println("ans", strs)
	return strs
}

func minimumEffort(tasks [][]int) int {
	// 二分法
	need, edge := 0, 0
	for _, task := range tasks {
		need += task[0]
		edge += task[1]
	}
	sort.Slice(tasks, func(i, j int) bool {
		// return tasks[i][1] > tasks[j][1]
		// return tasks[i][1] < tasks[j][1]
		// 33/34 个用例
		return (tasks[i][1] - tasks[i][0]) > (tasks[j][1] - tasks[j][0])
	})
	// fmt.Println(tasks)
	// 单纯的排序无法解决问题，需要 dfs, bfs
	left := need
	right := edge
	fmt.Println(left, right, len(tasks))
	for left < right {
		mid := left + (right-left)/2
		ret := pass(tasks, mid)
		// fmt.Println(left, right, mid, "pass", ret)
		if ret {
			right = mid
		} else {
			left++
		}
	}
	fmt.Println("ans", left)
	return left
}

// [[4738,7608],[3838,9478],[173,2857],[6139,9833],[5509,8352],[2942,3253],[870,6727],[4210,8378],[4581,5234],[2240,2261],[6750,9895],[3947,8168],[2907,7234],[1546,5789],[3388,9499],[5735,7075],[1709,7890],[4565,7808],[3779,4260],[4321,4610],[2981,9709],[418,7120],[2571,8119],[1063,7268],[6462,7480],[9492,9642],[2446,4869],[2276,3177],[2115,7614],[4383,7475],[4240,5242],[1280,7417],[4336,5767],[1028,6241],[922,4459],[721,3063],[5120,5267],[1818,7408],[1224,7859],[4172,4971],[3787,6326],[3614,4813],[6350,9148],[3761,3795],[3889,5846],[3886,4693],[3149,4945],[1189,7198],[1677,8510],[6125,7112],[2469,6213],[7590,9131],[5,1305],[7563,9006],[4096,4749],[1528,8672],[1183,6845],[2626,7098],[4786,6481],[277,8043],[2537,5264],[151,9109],[1765,8516],[489,8947],[4022,8205],[2236,5188],[644,1030],[989,2894],[6216,7476],[4390,9640],[3594,9320],[328,7237],[948,5889],[2250,2931],[1653,7167],[7045,9563],[1529,4810],[4391,6679],[3886,5121],[1135,6214],[374,3917],[1302,1723],[1156,3893],[1415,1999],[3247,3491],[4890,7112],[2449,5732],[6625,6946],[3268,6336],[5418,9394],[4501,5139],[7592,8864],[1719,9225],[2137,6469],[2592,9567],[3180,7759],[5982,6038],[389,9925],[5962,7983],[20,6489],[2082,6450],[2109,5612],[2906,3362],[326,5780]]
func pass(tasks [][]int, init int) bool {
	// // 需要使用 dfs, bfs 的方法才可以
	// ans := false
	// n := len(tasks)
	// var dfs func(now, leave int, used []bool)
	// dfs = func(now, leave int, used []bool) {
	// 	if now == n {
	// 		if leave >= 0 {
	// 			ans = true
	// 		}
	// 		return
	// 	}
	// 	if leave < 0 {
	// 		return
	// 	}
	// 	for index := 0; index < n; index++ {
	// 		if !used[index] && leave >= tasks[index][1] {
	// 			used[index] = true
	// 			dfs(now+1, leave-tasks[index][0], used)
	// 			used[index] = false
	// 		}
	// 	}
	// }
	// used := make([]bool, n)
	// dfs(0, init, used)
	// // for i := 0; i < n; i++ {
	// // 	dfs(i, init, used)
	// // }
	// return ans
	now := init
	for _, task := range tasks {
		if now < task[1] {
			return false
		}
		now -= task[0]
	}
	return now >= 0
}
